# [29.2. Подписка](https://postgrespro.ru/docs/postgresql/current/logical-replication-subscription)
Узел подписчика может подписываться на несколько подписок, если требуется. В одной паре публикующий сервер/подписчик могут быть определены несколько подписок, но при этом нужно позаботиться о том, чтобы публикуемые объекты в разных подписках не перекрывались.

Изменения в каждой подписке будут приходить через один слот репликации

Когда подписка удаляется и пересоздаётся, информация о синхронизации теряется. Это означает, что после этого данные необходимо синхронизировать заново.

Определения схемы не реплицируются, а публикуемые таблицы должны существовать в базе подписчика.

## 29.2.1. Управление слотами репликации
Обычно расположенный удалённо слот репликации автоматически создаётся при создании подписки командой CREATE SUBSCRIPTION подписка и автоматически удаляется при удалении подписки командой DROP SUBSCRIPTION. 

При ликвидации публикации может потребоваться сохранить слот репликации. Например, это полезно, когда нужно перенести базу данных подписчика на другой узел и активировать её там. В этом случае разорвите связь подписки со слотом, используя команду ALTER SUBSCRIPTION, прежде чем удалять подписку.

При ликвидации подписки расположенный удалённо узел может быть недоступен.  
> Если экземпляр базы данных оказался недоступным, слот репликации (и все оставшиеся слоты синхронизации таблиц) нужно будет удалить вручную;
> в противном случае публикующий сервер(ы) продолжит сохранять WAL и может в конце концов заполнить всё место на диске.

# [29.4. Фильтры строк](https://postgrespro.ru/docs/postgresql/current/logical-replication-row-filter#LOGICAL-REPLICATION-ROW-FILTER)
Если через публикацию реплицируются операции UPDATE или DELETE, предложение WHERE фильтра строк должно содержать только те столбцы, которые входят в идентификатор реплики 

# [29.5. Списки столбцов](https://postgrespro.ru/docs/postgresql/current/logical-replication-col-lists#LOGICAL-REPLICATION-COL-LISTS)
Если список столбцов не задан, все столбцы, добавляемые в таблицу позднее, будут реплицироваться автоматически. Это означает, что наличие списка, включающего все столбцы, не равнозначно отсутствию списка столбцов.

Генерируемые столбцы также можно указать в списке столбцов. Это позволяет публиковать генерируемые столбцы вне зависимости от параметра публикации publish_generated_columns.
Если на стороне подписчика используется версия ниже 18, то при первичной синхронизации таблиц генерируемые столбцы не скопируются, даже если они определены на публикующем узле.

# [29.7. Конфликты](https://postgrespro.ru/docs/postgresql/current/logical-replication-conflicts#LOGICAL-REPLICATION-CONFLICTS)
Операции логической репликации выполняются с правами роли, которой принадлежит подписка. 

Если в случае конфликта выдаётся ошибка, репликация останавливается. Разрешить возникшую проблему пользователь должен вручную. 

Разрешить конфликт можно, изменив данные или разрешения на стороне подписчика, чтобы они не конфликтовали с поступающими изменениями, или пропустив транзакцию, конфликтующую с существующими данными.

# [29.8. Ограничения](https://postgrespro.ru/docs/postgresql/current/logical-replication-restrictions#LOGICAL-REPLICATION-RESTRICTIONS)
Схема базы данных и команды DDL не реплицируются.

# [29.9. Архитектура](https://postgrespro.ru/docs/postgresql/current/logical-replication-architecture#LOGICAL-REPLICATION-ARCHITECTURE)
Процесс применения изменений в базе данных подписчика всегда выполняется со значением **session_replication_role** равным **replica**. 
Это означает, что **по умолчанию триггеры и правила не будут срабатывать на подписчике**. 

Процесс применения логической репликации в настоящее время вызывает только триггеры уровня строк, но не триггеры операторов. 
Однако **начальная синхронизация таблицы реализована как команда COPY** и поэтому вызывает триггеры для INSERT и уровня строк, и уровня оператора.

Начальные данные существующих таблиц в подписке помещаются в снимок и копируются в параллельном экземпляре процесса применения особого вида.
* Каждая синхронизация таблиц создаёт собственный слот репликации и производит **копирование** существующих данных.
* Когда существующие данные будут скопированы, этот рабочий процесс переходит в режим **синхронизации**, в котором таблица приводится в синхронизированное состояние для основного процесса применения, то есть передаёт все изменения, произошедшие во время начального копирования данных, используя стандартную логическую репликацию.
* По завершении синхронизации управление репликацией этой таблицы **возвращается главному процессу**, который продолжает репликацию в обычном режиме.

# [29.10. Мониторинг](https://postgrespro.ru/docs/postgresql/current/logical-replication-monitoring#LOGICAL-REPLICATION-MONITORING)
Информацию о подписке для мониторинга можно получить в представлении **pg_stat_subscription**. 

Это представление содержит по одной строке для каждого рабочего процесса подписчика. 

# [29.11. Безопасность](https://postgrespro.ru/docs/postgresql/current/logical-replication-security#LOGICAL-REPLICATION-SECURITY)
Чтобы создать публикацию, пользователь должен иметь право CREATE в базе данных.

Чтобы добавлять таблицы в публикацию, пользователь должен иметь права владельца для этих таблиц. 

Добавлять в публикацию все таблицы схемы может только суперпользователь. 

На данный момент прав для публикаций нет. Любая подписка (имеющая возможность подключения) может получить доступ к любой публикации.

Чтобы создать подписку, пользователь должен иметь права роли pg_create_subscription, а также права CREATE для базы данных.

Процесс применения подписки на уровне сеанса будет выполняться с правами владельца подписки. Однако при выполнении операции вставки, изменения, удаления или усечения в конкретной таблице происходит переключение роли на владельца таблицы и выполнит операцию с правами владельца таблицы. Это означает, что владелец подписки должен иметь право SET ROLE для каждой роли, которой принадлежит реплицируемая таблица.

Если подписка сконфигурирована с run_as_owner = true, переключение пользователей не произойдёт. 
> Однако это также означает, что любой пользователь, владеющий таблицей, в которую реплицируются данные, может выполнять произвольный код с правами владельца подписки. Например, это можно сделать, добавив триггер к одной из принадлежащих этому пользователю таблиц.
























