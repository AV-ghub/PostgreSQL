[Презентация](https://www.youtube.com/watch?v=9VyhG_spCzo&list=PLaFqU3KCWw6LPcuYVymLcXl3muC45mu3e&index=18)
[Материалы](https://edu.postgrespro.ru/dba1-13/dba1_17_backup_overview.html)

## Резервное копирование
### Логическое 
Набор инструкций, медленно, но с возможностью миграции на другие версии.

<details><summary><h4>COPY: копия таблицы</h4></summary>
  
  > Если требуется сохранить только содержимое одной таблицы.
  
  Команда позволяет записать таблицу (или результат произвольного запроса) либо в файл, либо на консоль, либо на вход произвольной программе.  
  При этом можно указать ряд параметров, таких как формат (текстовый, csv или двоичный), разделитель полей, текстовое представление NULL и др.
  
  Другой вариант команды, наоборот, считывает из файла или из консоли строки с полями и записывает их в таблицу. 
  Таблица при этом не очищается, новые строки добавляются к уже существующим.
  
  Команда COPY работает существенно быстрее, чем аналогичные команды INSERT — клиенту не нужно много раз обращаться к серверу, а серверу не нужно много раз анализировать команды.
  
  https://postgrespro.ru/docs/postgresql/13/sql-copy
  
  В psql существует клиентский вариант команды COPY с аналогичным синтаксисом. 
  В отличие от серверного варианта COPY, который является командой SQL, клиентский вариант — это команда psql.Указание имени файла в команде SQL соответствует файлу на сервере БД. 
  У пользователя, под которым работает PostgreSQL (обычно postgres), должен быть доступ к этому файлу. 
  В клиентском варианте обращение к файлу происходит на клиенте, а на сервер передается только содержимое.
  
  https://postgrespro.ru/docs/postgresql/13/app-psq
  
</details>
<details><summary><h4>pg_dump: копия базы</h4></summary>

  Для создания полноценной резервной копии базы данных используется утилита **pg_dump**. 
  
  В зависимости от указанных параметров, результатом работы является либо SQL-скрипт, содержащий команды, создающие выбранные объекты, либо файл в специальном формате с оглавлением.
  
  > Указание оглавления позволяет впоследствии восстановить только указанные объекты из списка.
  
  Поддерживает резервное ***копирование параллельно в несколько потоков***. При этом одна таблица всегда выгружается одним потоком. Несколько потоков делятся по отдельным объектам.
  
  Позволяет ограничить набор выгружаемых объектов (таблицы, схемы, только DML или только DDL и т. п.)
  
  Чтобы восстановить объекты из SQL-скрипта, достаточно прогнать его  через psql.
  
  https://postgrespro.ru/docs/postgresql/13/app-pgdump
  
  Для восстановления резервной копии в специальном формате требуется другая утилита — **pg_restore**. 
  
  Она читает файл и преобразует его в обычные команды psql. 
  Преимущество в том, что набор объектов можно ограничить не при создании резервной копии, а уже при восстановлении (при задании в pg_dump формата с оглавлением). 
  Кроме того, ***создание резервной копии в специальном формате и восстановление из нее может выполняться параллельно***.
  
  https://postgrespro.ru/docs/postgresql/13/app-pgrestore
  
  Базу данных для восстановления надо создавать из шаблона template0, так как все изменения, сделанные в template1, также попадутв резервную копию. 
  
  > Кроме того, при восстановлении в другом местоположении, заранее должны быть созданы необходимые роли и табличные пространства, поскольку эти объекты относятся ко всему кластеру. 
  
  После восстановления базы имеет смысл выполнить команду ANALYZE, которая соберет статистику.
  
</details>
<details><summary><h4>pg_dumpall: копия кластера</h4></summary>
  Сохраняет весь кластер, включая роли и табличные пространства, выдает на консоль или в файл SQL-скрипт.
  
  Параллельное выполнение не поддерживается, но 
  
  > можно выгрузить только глобальные объекты и воспользоваться pg_dump.

  Восстановлениес помощью psql.

  Поскольку pg_dumpall требуется доступ ко всем объектам всех БД, имеет смысл запускать ее от имени суперпользователя. 
  
  > Утилита по очереди подключается к каждой БД кластера и выгружает информацию с помощью **pg_dump**. 
  
  Кроме того, она сохраняет и данные, относящиеся к кластеру в целом.
  Результатом работы pg_dumpall является скрипт для psql. 
  Другие форматы не поддерживаются. 
  Это означает, что ***pg_dumpall не поддерживает параллельную выгрузку данных***, что может оказаться проблемой при больших объемах данных. 
  В таком случае можно воспользоваться ключом **--globals-only**, чтобы выгрузить только роли и табличные пространства, а сами базы данных выгрузить с помощью pg_dump.
  
  https://postgrespro.ru/docs/postgresql/13/app-pg-dumpal
</details>

### Физическое
Физическое копирование файлов. Восстановление только строго на той же архитектуре. Т.е. если копия делалась на 13 PG версии в Ubuntu, то восстановиться сможем ровно туда же.
<details><summary><h4>утилита pg_basebackup</h4></summary>
  
  Для создания горячей резервной копии существует утилита **pg_basebackup**.
  
  Вначале утилита выполняет ***контрольную точку***. 
  Затем копируется ***файловая система*** кластера.
  Все ***файлы WAL***, сгенерированные сервером за время от контрольной точки до окончания копирования файлов, также копируются в резервную копию. 
  
  Такая копия называется автономной, поскольку содержит в себе все необходимое для восстановления.
  Для восстановления достаточно развернуть резервную копию и запустить сервер. 
  При необходимости он выполнит восстановление согласованности с помощью имеющихся файлов WAL и будет готовк работе.
  
  https://postgrespro.ru/docs/postgresql/13/app-pgbasebackup

  ##### Протокол репликации
  Чтобы сохранить все необходимые для восстановления файлы WAL, сгенерированные сервером за время копирования файлов, утилита подключается к серверу по специальному протоколу репликации. 
  Несмотря на название, это протокол используется не только для репликации, но и для резервного копирования. 
  Протокол ***позволяет получать поток журнальных записей*** параллельно с копированием файлом.
  
  Чтобы сервер не удалил необходимые файлы WAL преждевременно, может использоваться ***слот репликации***.
  
  Для того, чтобы подключение было возможно, необходим ряд настроек.
  * Во-первых, роль должна обладать атрибутом **REPLICATION** (или быть суперпользователем).
  * Кроме того, этой роли должно быть выдано разрешение в конфигурационном файле **pg_hba.conf**.
  * Во-вторых, параметр **max_wal_senders** должен быть установленв достаточно большое значение. Этот параметр ограничивает число одновременно работающих процессов wal_sender, обслуживающих подключения по протоколу репликации.
  * В-третьих, параметр **wal_level**, определяющий количество информации в журнале, должен быть установлен в значение replica.
  
  > Начиная с версии 10, настройки по умолчанию уже включают все эти требования (при локальном подключении).
  
  https://postgrespro.ru/docs/postgresql/13/protocol-replication

  ##### Файловый архив журналов
  Файловый архив реализуется фоновым процессом **archiver**.
  PostgreSQL позволяет определить для копирования произвольную команду shell в параметре **archive_command**. 
  Сам механизм включается параметром **archive_mode = on**.
  
  Общий алгоритм таков. При заполнении очередного сегмента WAL вызывается команда копирования. 
  Если она завершается с нулевым статусом, то сегмент может быть удален. 
  Если же нет, то сегмент(и следующие за ним) не будет удален, а сервер будет периодически пытаться выполнить команду, пока не получит 0. 
  
  https://postgrespro.ru/docs/postgresql/13/continuous-archiving

  ##### Потоковый архив журналов
  Утилита pg_receivewal подключается по протоколу репликации (можно использовать слот) и направляет поток записей WAL в файлы-сегменты
  * стартовая позиция — начало сегмента, следующего за последним заполненным сегментом, найденным в каталоге, или начало текущего сегмента сервера, если каталог пустой
  * в отличие от файлового архива, ***записи пишутся постоянно***
  * при переходе на новый сервер надо перенастраивать параметры

  Обычно утилита запускается на отдельном «архивном» сервере и подключается к мастеру с параметрами, указанными в ключах. 
  Утилита может (и должна) использовать слот репликации, чтобы гарантированно не потерять записи.
  Утилита формирует файлы аналогично тому, как это делает сервер, и записывает их в указанный каталог. 
  Еще не заполненные сегменты записываются с префиксом .partial.
  Архивирование всегда начинается с начала сегмента, следующего за последним заполненным сегментом архива. 
  Если архив пуст (первый запуск), архивирование начинается с начала текущего сегмента.
  При переходе на новый сервер утилиту требуется остановить и запустить заново с соответствующими параметрами.
  Требуется учесть, что сама по себе утилита не запускается автоматически (как сервис) и не демонизируется.
  
  https://postgrespro.ru/docs/postgresql/13/app-pgreceivewal
  
</details>









