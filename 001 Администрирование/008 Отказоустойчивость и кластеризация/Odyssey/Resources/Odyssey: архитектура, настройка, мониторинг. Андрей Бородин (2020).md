[src](https://habr.com/ru/articles/498250/)

## Обзор
Соединений с постмастером Postgres должно быть, как можно меньше, потому что ***одно соединение – это один бэкенд, один процесс форкнутый постмастера***.

И на этом процессе висят различные ***кэши, которые желательно поддерживать и не плодить*** многократно.

Можно применять pooler, который находится между базой данных и вашим приложением. 

Есть **Pgpool II**. Это программа, которая умеет много всего. Она умеет распределять читающие и пишущие запросы. Она пытается понять суть ваших запросов. Но ***из-за того, что она делает много чего, в ней есть и проблема***.

Есть **Crunchy-Proxy**. Это интересная попутка компании Crunchy Data создать свой Proxy pooler. Написан он на Go, но проект как-то сейчас ***не очень развивается***.

Есть простой и понятный **PgBouncer**. Это pooler соединений, который предназначен для транзакционного pooling. И он старается больше ничего не делать. Это утилита, которая ***делает одну задачу, поэтому делает ее хорошо***.

И ***в большинстве случаев для нашей нагрузки в каком-то виде подходит PgBouncer***.

## Проблемы с PgBouncer
PgBouncer не говорит, почему не смог открыть серверное соединение. У вас ***нет никакого кода ошибки***.

PgBouncer ***спроектирован однопоточным***. CPU мы видим 97 % загрузки. База при этом не так, чтобы занята, но Bouncer не успевает передавать байтики туда и сюда. Раньше надо было накладывать небольшой патчик, который позволял PgBouncer ***разделять порт*** с другим PgBouncer. Теперь эта технология уже поддержана в PgBouncer, даже патч накладывать не надо. Нужно просто ***настроить reuseport***.

PgBouncer ***имитирует поведение базы данных в части потерянного соединения***. Если у вас приложение по какой-то причине бросило соединение с базой данных, то PgBouncer продолжит выполнять тот запрос, который выполнялся.

## Odyssey
Odyssey основан на двух библиотеках. Одна называется Kiwi, другая Machinarium.

**Библиотека Kiwi** занимается ***обработкой протокола Postgres***. Стандартный протокол Postgres по обмену сообщениями Proto3. Для каждого из сообщений в Kiwi написана функциональность, которая позволяет по простому его отформатировать и отправить единообразно, как если бы вы являлись клиентом или сервером. 

**Machinarium** – более сложная библиотека, которая предназначена для ***организации многопоточных вычислений и для обработки сообщений о событиях***.

В Machinarium есть машины. Машина – это, по сути, thread прибитый к определенному процессорному ядру. И на нем могут регистрироваться корутины. Корутина – это программа, которая получает время центрального процессора от шедулера операционной системы. 

У нас есть main-машина, т. е. main-поток, в котором есть одна корутина, которая обслуживает сокет. Просматривает наличие соединения в бэклоге. Если видит входящее TCP-соединение, то ***создает в одном из воркеров новую машину***, которой передается соединение. При этом ***не происходит каких-то форков, просто передается одно сообщение в канале*** о том, что нужно запустить новую корутину, которая будет заниматься обслуживанием работы одного соединения.

За счет корутинового подхода, работа одной машины по обслуживанию одного клиентского соединения описывается ***не машиной состояний, а последовательным вызовом***. Это последовательная программа, которая значительно легче в восприятии, чем машина состояний, когда вы, по сути, пишите условия. Например, если я на прошлом выходе был в состоянии ожидания аутентификации, то я проверяю завершение аутентификации. Или если я был в состоянии открытия сервера, то я проверяю доступен ли мне сервер.
***
> в коде PgBouncer мы потом нашли довольно длинный комментарий на тему того, что ***открытие серверного соединения значительно дороже, чем выполнение большинства OLTP-запросов***. Поэтому даже если pooler сконфигурирован в режиме большого количества соединений в пуле, то ***не нужно открывать их все сразу***
***
> Мы пошли в код PgBouncer и нашли там длинный комментарий о том, что ***медленные клиенты – это такая же проблема, как и слишком быстрые клиенты***. И что если клиент находится в состоянии аутентификации или установки TLS handshake, но ***ничего не говорит 15 секунд, то PgBouncer его выкидывает***.
***

## Настройка и мониторинг
Odyssey может слушать одновременно несколько портов, при этом с разными настройками, с разными TLS-соединениями. И за это отвечает блок конфигурации **listen**.

Раздел конфигурации **Storage** – это описание способа соединений с физически существующей базой данных. 

И последнее, что надо настроить – это **связки database и user**, в которых мы описываем, какого размера должен быть пул. Описываем, через какое время нужно отключать клиента, если ему не удалось найти сервер. И нужно ли пробрасывать ошибки.

Кстати, одна из настроек Postgres – это **client_fwd_error**. Если вы ставите «no», то мы имитируем поведение Bouncer. Т. е. если по какой-то причине мы не можем установить соединение с сервером, мы бросим ту же самую ошибку, которую бросает Bouncer. Если тут будет по дефолту написано «yes», то мы перебросим вам ту ошибку, которую вам пытался сказать Postgres.

**Pool_cancel и pool_rollback** – это настройки, которые говорят о том, что если у нас порвалось клиентское соединение, то должны ли мы откатить транзакцию, которая находилась в прогрессе или должны ли мы отправить cancel выполняющемуся запросу.

**Application_name_add_host** – это аналогичная настройка Bouncer, которая говорит о том, что нам нужно добавить ip-адрес клиентского соединения к application_name серверного соединения.

Зачем нужны **квантили**? Bouncer возвращает вам среднее время транзакции и среднее время запроса. Но среднее время не дает вам никакого понимания о том, что на самом деле происходит. Если у вас есть 10 % очень медленных запросов, а все остальные запросы мгновенные, то в среднем вы увидите, что база как-то работает. А на самом деле 10 % пользователей уже страдают.

При этом 0,99 квантиль говорит о том, что 99 % ответов укладываются в данном случае в 1,273 миллисекунды. И он уже достаточно хорошо показывает, что ваша база совсем сложилась или просто немножко там стало похуже. Единственное, что квантили лучше выводить на графике, потому что мгновенные значения квантилей – это тоже не очень хорошо помогает в диагностике.

## Мониторинг
**Utilization** – это процессорное время выполнения воркеров Odyssey. Если у вас выделено 4 воркера, то это означает, что Odyssey может работать на 4-х процессорах. И если вы видите утилизацию в 400 %, то, скорее всего, вам нужно больше воркеров.

**Saturation и Errors** в нашем случае – это одно и то же, потому что и то и другое сводится к анализу логов Odyssey, в которых нужно подсчитывать количество соединений, которым не удалось получить серверное соединение. Количество ошибок будет вам говорить о перегрузке времени центрального процессора. И какие-то другие ошибки, которые не вписываются в стандартный паттерн.

