[src](https://postgrespro.ru/docs/postgresql/16/datatype-json)  

# 8.14. Типы JSON

Типы JSON предназначены для хранения данных JSON (JavaScript Object Notation). Такие данные можно хранить и в типе text, но типы JSON лучше тем, что проверяют, соответствует ли вводимое значение формату JSON. Для работы с ними есть также несколько специальных функций и операторов; см. Раздел 9.16.

В PostgreSQL имеются _**два типа для хранения**_ данных JSON: **json** и **jsonb**. Для реализации эффективного механизма запросов к этим типам данных в PostgreSQL также имеется тип **jsonpath**, описанный в Подразделе 8.14.7.

Тип _**json сохраняет точную копию**_ введённого текста, которую функции обработки должны разбирать заново при каждом выполнении запроса, тогда как данные _**jsonb сохраняются в разобранном двоичном формате**_, что несколько замедляет ввод из-за преобразования, но значительно _**ускоряет обработку, не требуя многократного разбора**_ текста. Кроме того, jsonb _**поддерживает индексацию**_, что тоже может быть очень полезно.

Тип jsonb не сохраняет пробелы, порядок ключей и значения с дублирующимися ключами. Если во входных данных оказываются дублирующиеся ключи, сохраняется только последнее значение.

Для большинства приложений предпочтительнее хранить данные JSON в типе jsonb (если нет особых противопоказаний, например важны прежние предположения о порядке ключей объектов).

В RFC 7159 говорится, что строки JSON должны быть представлены в кодировке UTF-8. Поэтому _**данные JSON не будут полностью соответствовать спецификации, если кодировка базы данных не UTF-8**_. При этом нельзя будет вставить в JSON символы, непредставимые в кодировке сервера, и наоборот, допустимыми будут символы, представимые в кодировке сервера, но не в UTF-8.

При преобразовании вводимого текста JSON в тип jsonb, _**примитивные типы**_, описанные в RFC 7159, по сути _**отображаются в собственные типы PostgreSQL**_ как показано в Таблице 8.23. 

И напротив, как показано в таблице, есть некоторые ограничения в формате ввода примитивных типов JSON, не актуальные для соответствующих типов PostgreSQL.

## 8.14.1. Синтаксис вводимых и выводимых значений JSON 
Примеры допустимых выражений с типом json (или jsonb):
```
-- Простое скалярное/примитивное значение
-- Простыми значениями могут быть числа, строки в кавычках, true, false или null
SELECT '5'::json;
```
```
-- Массив из нуля и более элементов (элементы могут быть разных типов)
SELECT '[1, 2, "foo", null]'::json;
```
```
-- Объект, содержащий пары ключей и значений
-- Заметьте, что ключи объектов — это всегда строки в кавычках
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;
```
```
-- Массивы и объекты могут вкладываться произвольным образом
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;
```
Как было сказано ранее, когда значение JSON вводится и затем выводится без дополнительной обработки, тип json выводит тот же текст, что поступил на вход, а jsonb не сохраняет семантически незначащие детали, такие как пробелы. Например, посмотрите на эти различия:
```
SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json
-------------------------------------------------
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)
```
```
SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb
--------------------------------------------------
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)
```
Первая семантически незначимая деталь, заслуживающая внимания: с jsonb числа выводятся по правилам нижележащего типа numeric. На практике это означает, что числа, заданные в записи с E, будут выведены без неё, например:
```
SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb
-----------------------+-------------------------
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)
```
Однако как видно из этого примера, jsonb сохраняет конечные нули дробного числа, хотя они и не имеют семантической значимости, в частности для проверки на равенство.

Список встроенных функций и операторов, позволяющих создавать и обрабатывать значения JSON, приведён в Разделе 9.16.

## 8.14.2. Проектирование документов JSON 
Представлять данные в JSON можно гораздо более гибко, чем в традиционной реляционной модели данных, что очень привлекательно там, где нет жёстких условий. И оба этих подхода вполне могут сосуществовать и дополнять друг друга в одном приложении. Однако даже для приложений, которым нужна максимальная гибкость, рекомендуется, чтобы документы JSON имели некоторую фиксированную структуру. Эта структура обычно не навязывается жёстко (хотя можно декларативно диктовать некоторые бизнес-правила), но когда она предсказуема, становится гораздо проще писать запросы, которые извлекают полезные данные из набора «документов» (информации) в таблице.

_**Данные JSON**_, как и данные любых других типов, хранящиеся в таблицах, _**находятся под контролем механизма параллельного доступа**_. Хотя хранить большие документы вполне возможно, не забывайте, что _**при любом изменении устанавливается блокировка всей строки**_ (на уровне строки). Поэтому для оптимизации блокировок транзакций, изменяющих данные, стоит ограничить размер документов JSON разумными пределами. В идеале каждый документ JSON должен собой представлять атомарный информационный блок, который, согласно бизнес-логике, нельзя разделить на меньшие, индивидуально изменяемые блоки.

## 8.14.3. Проверки на вхождение и существование jsonb 
**Проверка вхождения** — важная особенность типа jsonb, не имеющая аналога для типа json. Эта проверка определяет, _**входит ли один документ jsonb в другой**_. 

## 8.14.4. Индексация jsonb 
Для эффективного поиска ключей или пар ключ/значение в большом количестве документов jsonb _**можно успешно применять индексы GIN**_. Для этого предоставляются два «класса операторов» GIN, предлагающие выбор между производительностью и гибкостью.

## 8.14.5. Обращение по индексу к элементам jsonb 
Тип данных jsonb поддерживает извлечение и изменение элементов в стиле обращения к элементам массива. Указывать на вложенные значения можно, задавая цепочку обращений к элементам, при этом будут действовать правила использования аргумента path функции jsonb_set. 

Используя операцию обращения по индексу в предложении SET оператора UPDATE, _**можно изменять значения jsonb**_. 

## 8.14.6. Трансформации 
Для различных процедурных языков представлены дополнительные расширения, реализующие трансформации для типа jsonb.

Расширения для PL/Perl называются jsonb_plperl и jsonb_plperlu. Когда они используются, значения jsonb отображаются в соответствующие структуры Perl: массивы, хеши или скаляры.

Расширение для PL/Python называется jsonb_plpython3u. Когда оно используется, значения jsonb отображаются в соответствующие структуры Python: словари, списки или скаляры.

Из этих расширений «доверенным» считается jsonb_plperl, то есть его могут устанавливать обычные пользователи, имеющие право CREATE в текущей базе данных. Остальные расширения могут устанавливать только суперпользователи.

## 8.14.7. Тип jsonpath 
Тип jsonpath предназначен для реализации поддержки языка путей SQL/JSON в PostgreSQL, позволяющего эффективно выполнять запросы к данным JSON. Он обеспечивает двоичное представление разобранного выражения пути SQL/JSON, определяющего, какие элементы должны извлекаться из данных JSON для дальнейшей обработки в функциях SQL/JSON.

Семантика предикатов и операторов языка путей SQL/JSON в целом соответствует SQL. В то же время, чтобы с данными JSON можно было оперировать естественным образом, в синтаксисе путей SQL/JSON приняты некоторые соглашения JavaScript:


