## Настройка дисковой подсистемы
[Группа настроек vm.dirty_*ratio](https://github.com/AV-ghub/PostgreSQL/blob/main/004%20%D0%9E%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8/%D0%A1%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D0%B8/%D0%A7%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5/%D0%93%D1%80%D1%83%D0%BF%D0%BF%D0%B0%20%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BA%20vm.dirty_*ratio.md)
   
#### Disabling drive write caches [3](https://github.com/AV-ghub/PostgreSQL/blob/main/998%20Books/List.md).[39]

#### Complicated disk benchmarks [3](https://github.com/AV-ghub/PostgreSQL/blob/main/998%20Books/List.md).[67]

<details><summary><h4>General Linux filesystem tuning</h5></summary>

   #### Read-ahead [3](https://github.com/AV-ghub/PostgreSQL/blob/main/998%20Books/List.md).[87]

   When doing sequential reads that seem to be moving forward, this feature results in Linux asking for blocks from the disk ahead of the application requesting them.  
   The usual symptom of insufficient readahead is noting that write speed to a disk is faster than its read speed. The impact is not subtle; proper read-ahead can easily result in 100% or larger increase in sequential read performance.  
   That corresponds to a big increase in large sequential I/O operations in PostgreSQL, too, including sequential scans of tables and bulk operations like COPY imports.  
   You can check your current read-ahead using the blockdev command:
   ```
   $ blockdev --getra /dev/sda
   ```
   The default is **256** for regular drives, and may be larger for software RAID devices. The units here are normally 512 bytes, making the default value equal to 128 KB of read-ahead. The normal properly tuned range on current hardware usually works out to be **4096** to **16384**, making this change:
   ```
   $ blockdev --setra 4096 /dev/sda
   ```
   Unfortunately, read-ahead needs to be set for each drive on your system. It's usually handled by putting a blockdev adjustment for each device in the rc.local boot script. 
   > The Linux read-ahead implementation was developed with PostgreSQL as an initial target, and it's unlikely you will discover increased read-ahead detuning smaller reads as you might fear. The implementation is a bit smarter than that.
 
   #### File access times
   Each time you access a file in Linux, a file attribute called the file's last access time (atime) is updated. This overhead turns into a steady stream of writes when you're reading data, which is an unwelcome overhead when working with a database. You can disable this behaviour by adding noatime to the volume mount options in /etc/fstab, as in this example:
   ```
   /dev/sda1 / ext3 noatime,errors=remount-ro 0 1
   ```

   #### Read caching and swapping
   You can check the current value on your system (probably 60) by looking at _**/proc/sys/vm/swappiness**_ and the easiest way to make a permanent adjustment is to add a line to _**/etc/sysctl.conf**_ like this:
   ```
   vm.swappiness=0
   ```
   A value of 0 prefers shrinking the filesystem cache rather than using swap, _**which is the recommended behavior for getting predictable database performance**_.

   Related to this parameter is Linux's tendency to let processes allocate more RAM than the system has, in the hopes that not all of it will actually be used. This Linux overcommit
behaviour should be disabled on a PostgreSQL server by making this change to the sysctl configuration:
   ```
   vm.overcommit_memory=2
   ```
   _**Both of these changes should be considered as part of setting up any Linux PostgreSQL server**_. A good practice here is _**to bundle them in with increasing the shared memory parameters to support larger values of**_ **shared_buffers**, which requires editing the same sysctl file.

   #### Write cache sizing
   The default here depends on your kernel version. In early 2.6 kernels, _**dirty_background_ratio=10 and dirty_ratio=40**_. This means that a full 10% of RAM can be dirty before pdflush really considers it important to work on clearing that backlog.
   You can tune an older kernel to use the new defaults like this:
   ```
   echo 10 > /proc/sys/vm/dirty_ratio
   echo 5 > /proc/sys/vm/dirty_background_ratio
   ```
   #### I/O scheduler elevator [3](https://github.com/AV-ghub/PostgreSQL/blob/main/998%20Books/List.md).[90]
   The reality is that these are being covered last because _**this is the least-effective**_ tunable mentioned in this section.   
   Adjusting the I/O scheduler in most cases has a minimal impact on PostgreSQL performance.  
   If you want to improve read performance, adjusting _**read-ahead is vastly more important**_.  
   And if you want to tweak write performance, adjusting the _**dirty cache writeback behavior is the primary thing**_ to consider  
   (after tuning the database to reduce how much dirty data it generates in the first place).
   
   

</details>













