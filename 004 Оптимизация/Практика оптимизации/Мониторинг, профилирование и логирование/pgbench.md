[pgbench](https://postgrespro.ru/docs/postgresql/16/pgbench)    
[pgbench & others: Benechmarking PostGreSQL Server](https://github.com/AbdallahCoptan/PostGreSQL-Bench/blob/master/Pgbench.md)

<details><summary><h5>Инициализация</h5></summary>

Для запускаемого по умолчанию теста типа TPC-B требуется предварительно подготовить определённые таблицы.     
Чтобы создать и наполнить эти таблицы, следует запустить 
```sql
pgbench -i dbname
```
> Чтобы указать, как подключиться к серверу баз данных, вы также можете добавить параметры -h, -p и/или -U    

> pgbench -i создаёт четыре таблицы pgbench_accounts, pgbench_branches, pgbench_history и pgbench_tellers, предварительно уничтожая существующие таблицы с этими именами.    

С «коэффициентом масштаба», по умолчанию равным 1, эти таблицы изначально содержат такое количество строк:
```bash
table                   # of rows
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
```
[Скрипт](https://github.com/AV-ghub/PostgreSQL/blob/main/001%20%D0%90%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/010%20%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/002%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D1%8B%D0%B5%20%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D1%8B.md#%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D1%8B-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86-%D1%81-%D0%BA%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%BC-%D1%81%D1%82%D1%80%D0%BE%D0%BA) [Скрипт 2](https://github.com/AV-ghub/PostgreSQL/blob/main/001%20%D0%90%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/010%20%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/002%20%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D1%8B%D0%B5%20%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D1%8B.md#%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D1%8B-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86-%D1%81-%D0%BA%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%BC-%D1%81%D1%82%D1%80%D0%BE%D0%BA-2)

Эти числа можно (и в большинстве случаев даже нужно) увеличить, воспользовавшись параметром -s (коэффициент масштаба).    
При этом также может быть полезен ключ -F (фактор заполнения).

</details>
<details><summary><h5>Использование</h5></summary>

Подготовив требуемую конфигурацию, можно запустить тест производительности командой без -i, то есть:
```sql
pgbench [ параметры ] имя_базы
```
##### Наиболее важные параметры
* -c (число клиентов)
* -t (число транзакций)
* -T (длительность)
* -f (файл со скриптом)

</details>

<details><summary><h5>Параметры инициализации</h5></summary>

##### -i (--initialize) Требуется для вызова режима инициализации.

##### -I этапы_инициализации
####  d (Drop, удалить) 
Удалить все существующие таблицы pgbench.    
####  t (create Tables, создать таблицы) 
Создать таблицы, используемые стандартным сценарием pgbench, а именно: pgbench_accounts, pgbench_branches, pgbench_history и pgbench_tellers.  
####  g 
сгенерировать данные на стороне клиента    
####  G 
сгенерировать данные на стороне сервера   
####  v 
Вызывать VACUUM для стандартных таблиц   
####  p 
Создать первичные ключи в стандартных таблицах   
####  f
Создать ограничения внешних ключей между стандартными таблицами   
####  -F (--fillfactor) 
Создать таблицы pgbench_accounts, pgbench_tellers и pgbench_branches с заданным фактором заполнения. Значение по умолчанию — 100.   
####  -n (--no-vacuum) 
Этот параметр выключает этап инициализации v, даже если он был указан в -I   
####  -q (--quiet) 
Выводится только одно сообщение о прогрессе в 5 секунд (для параметра g)   
####  -s (--scale=коэффициент_масштаба) 
Умножить число генерируемых строк на заданный коэффициент.

####  --foreign-keys 
Создать ограничения внешних ключей между стандартными таблицами   
####  --index-tablespace=табл_пространство_индексов 
Создать индексы в указанном табличном пространстве, а не в пространстве по умолчанию.   
####  --partition-method=ИМЯ 
Создать секционированную таблицу pgbench_accounts, применив метод ИМЯ (это может быть range или hash).   
####  --partitions=ЧИСЛО 
Создать секционированную таблицу pgbench_accounts   
####  --tablespace=табличное_пространство 
Создать таблицы в указанном табличном пространстве, а не в пространстве по умолчанию.   
####  --unlogged-tables 
Создать все таблицы как нежурналируемые, а не как постоянные таблицы.   
  
</details>

<details><summary><h5>Параметры тестирования производительности</h5></summary>

#### -b имя_скрипта[@вес] --builtin=имя_скрипта[@вес] 
***Добавляет в список скриптов***, которые будут выполняться, указанный ***встроенный скрипт***.    
В число встроенных скриптов входят: 
* tpcb-like
* simple-update
* select-only

Также принимаются однозначные начала их имён. Со специальным именем list программа выводит список встроенных скриптов и немедленно завершается.   
Дополнительно можно задать целочисленный вес после @, меняющий вероятность выбора этого скрипта относительно других. По умолчанию вес считается равным 1. Подробности следуют ниже.
#### -c клиенты --client=клиенты 
Число имитируемых клиентов, то есть число одновременных сеансов базы данных. Значение по умолчанию — 1.
#### -C --connect 
Устанавливать новое подключение для каждой транзакции вместо одного для каждого клиента. Это полезно для оценивания издержек подключений.
#### -d --debug 
Выводить отладочные сообщения.
#### -D имя_переменной=значение --define=имя_переменной=значение 
Определить переменную для пользовательского скрипта (см. ниже). Параметр -D может добавляться неоднократно.
#### -f имя_файла[@вес] --file=имя_файла[@вес] 
Добавить в список выполняемых скриптов скрипт транзакции из файла имя_файла.   
Дополнительно можно задать целочисленный вес после @, меняющий вероятность выбора этого скрипта относительно других. По умолчанию вес считается равным 1. (Если вам нужно передать имя скрипта, содержащее символ @, добавьте к такому имени вес, чтобы исключить неоднозначность прочтения, например filen@me@1.) Подробности следуют ниже.
#### -j потоки --jobs=потоки 
Число рабочих потоков в pgbench. Использовать нескольких потоков может быть полезно на многопроцессорных компьютерах. Клиенты распределяются по доступным потокам равномерно, насколько это возможно. Значение по умолчанию — 1.
#### -l --log 
Записать информацию о каждой транзакции в файл протокола. Подробности описаны ниже.
#### -L предел --latency-limit=предел 
Транзакции, продолжающиеся дольше указанного предела (в миллисекундах), подсчитываются и отмечаются отдельно, как опаздывающие.   
В режиме ограничения скорости (--rate=...) транзакции, которые отстают от графика более чем на заданный предел (в мс) и поэтому никак не могут уложиться в отведённый интервал, не передаются серверу вовсе. Они подсчитываются и отмечаются отдельно как пропущенные.   
Когда используется параметр --max-tries, транзакция, прерванная из-за аномалии сериализации или взаимоблокировки, не будет повторяться, если общее время всех её повторений превышает предел в миллисекундах. Чтобы ограничить только общее время повторений, а не их количество, установите значение --max-tries=0. По умолчанию параметр --max-tries имеет значение 1, и транзакции с ошибками сериализации/взаимоблокировки не повторяются. Подробнее о повторных попытках выполнения таких транзакций рассказывается в Повторы и отказы из-за ошибок сериализации/взаимоблокировки.
#### -M режим_запросов --protocol=режим_запросов 
Протокол, выбираемый для передачи запросов на сервер:   
* simple: использовать простой протокол запросов
* extended: использовать расширенный протокол запросов
* prepared: использовать расширенный протокол запросов с подготовленными операторами   

В режиме prepared pgbench повторно использует результат разбора запроса, начиная со второй итерации, и поэтому работает быстрее, чем в других режимах.   
По умолчанию выбирается простой протокол запросов.
#### -n --no-vacuum 
Не производить очистку таблиц перед запуском теста. Этот параметр необходим, если вы применяете собственный сценарий, не затрагивающий стандартные таблицы pgbench_accounts, pgbench_branches, pgbench_history и pgbench_tellers.
#### -N --skip-some-updates 
Запустить встроенный упрощённый скрипт simple-update. Краткий вариант записи -b simple-update.
#### -P сек --progress=сек 
Выводить отчёт о прогрессе через заданное число секунд (сек). Выдаваемый отчёт включает время, прошедшее с момента запуска, скорость (в TPS) с момента предыдущего отчёта, а также среднее время ожидания транзакций, стандартное отклонение и количество неуспешных транзакций с момента последнего отчёта. В режиме ограничения скорости (-R) время ожидания вычисляется относительно назначенного времени запуска транзакции, а не фактического времени её начала, так что оно включает и среднее время отставания от графика. Когда параметр --max-tries включает повторение транзакций после ошибок сериализации/взаимоблокировок, в отчёт добавляется количество повторявшихся транзакций и общее число повторов.
#### -r --report-per-command 
Выдать следующую статистику по каждой команде после завершения теста: 
* среднюю длительность выполнения операторов (время выполнения с точки зрения клиента)
* число отказов и повторений вследствие ошибок сериализации и взаимоблокировки в этой команде   

Статистика повторений отображается в отчёте, только если параметр --max-tries не равен 1.
#### -R скорость передачи --rate=скорость передачи 
Выполнять транзакции, ориентируясь на заданную скорость, а не максимально быстро (по умолчанию). Скорость задаётся в транзакциях в секунду. Если заданная скорость превышает максимально возможную, это ограничение скорости не повлияет на результаты.   
Для получения нужной скорости транзакции запускаются со случайными задержками, имеющими распределение Пуассона. При этом запланированное время запуска отсчитывается от начального времени, а не от завершения предыдущей транзакции. Это означает, что если какие-то транзакции отстанут от изначально рассчитанного времени завершения, всё же возможно, что последующие нагонят график.   
В режиме ограничения скорости время ожидания транзакций, выводимое по итогам тестирования, вычисляется, исходя из запланированного времени запуска, так что в него входит время, которое очередная транзакция должна была ждать завершения предыдущей транзакции. Это время называется временем отклонения от графика, и его среднее и максимальное значения выводятся отдельно. 
Время ожидания транзакций с момента их фактического запуска, то есть время, потраченное на выполнение транзакций в базе данных, можно получить, если вычесть время отклонения от графика из времени ожидания транзакций.   
Если ограничение --latency-limit задаётся вместе с --rate, транзакция может заведомо не вписываться в отведённое ей время, если предыдущая транзакция завершится слишком поздно, так как ожидаемое время окончания транзакции отсчитывается от времени запуска по графику. Такие транзакции не передаются серверу, а пропускаются и подсчитываются отдельно.   
***Большое значение отклонения от графика свидетельствует о том, что система не успевает выполнять транзакции с заданной скоростью и выбранным числом клиентов и потоков***. Когда среднее время ожидания транзакции превышает запланированный интервал между транзакциями, каждая последующая транзакция будет отставать от графика, и чем дольше будет выполняться тестирование, тем больше будет отставание. Когда это наблюдается, нужно уменьшить скорость транзакций.
#### -s коэффициент_масштаба --scale=коэффициент_масштаба 
Показать заданный коэффициент масштаба в выводе pgbench. Для встроенных тестов это не требуется; корректный коэффициент масштаба будет получен в результате подсчёта строк в таблице pgbench_branches. Однако при использовании только нестандартных тестов (запускаемых с ключом -f) без этого параметра в качестве коэффициента масштаба будет выводиться 1.
#### -S --select-only 
Запустить встроенный скрипт select-only (только выборка). Краткий вариант записи -b select-only.
#### -t транзакции --transactions=транзакции 
Число транзакций, которые будут выполняться каждым клиентом (по умолчанию 10).
#### -T секунды --time=секунды 
Выполнять тест с ограничением по времени (в секундах), а не по числу транзакций для каждого клиента. Параметры -t и -T являются взаимоисключающими.
#### -v --vacuum-all 
Очищать все четыре стандартные таблицы перед запуском теста. Без параметров -n и -v pgbench будет очищать от старых записей таблицы pgbench_tellers и pgbench_branches, а также опустошать pgbench_history.
#### --aggregate-interval=секунды 
Длительность интервала агрегации (в секундах). Может использоваться только с ключом -l. С данным параметром в протокол выводится сводка по интервалам, как описано ниже.
#### --failures-detailed 
Выдавать информацию об ошибках в протоколе по транзакциям и в протоколе с агрегированием, а также в основном отчёте и в отчётах по скриптам, группируя её по типам:
* ошибки сериализации;
* ошибки взаимоблокировки;
#### --log-prefix=префикс 
Задать префикс имён файлов для файлов протоколов, создаваемых с ключом --log. Префикс по умолчанию — pgbench_log.
#### --max-tries=число_попыток 
Разрешить повторение транзакций с ошибками сериализации/взаимоблокировки и установить максимальное число попыток выполнения транзакций. Этот параметр можно комбинировать с параметром --latency-limit, который ограничивает общее время всех попыток для транзакции; также заметьте, что нельзя выбрать неограниченное количество попыток (--max-tries=0), не определив --latency-limit или --time. Значение по умолчанию — 1, то есть транзакции с ошибками сериализации/взаимоблокировки повторяться не будут. Подробнее о повторении таких транзакций рассказывается в Повторы и отказы из-за ошибок сериализации/взаимоблокировки.
#### --progress-timestamp 
При отображении прогресса (с параметром -P) выводить текущее время (в формате Unix), а не количество секунд от начала запуска. Время задаётся в секундах с точностью до миллисекунд. Это помогает сравнивать журналы, записываемые разными средствами.
#### --random-seed=затравка 
Установить затравку для генератора случайных чисел. Инициализирует генератор случайных чисел, который затем выдаёт последовательность начальных состояний отдельных генераторов для каждого потока.    
затравка может принимать следующие значения: 
* time (по умолчанию, затравка базируется на текущем времени)
* rand (задействовать надёжный генератор случайных чисел или выдать ошибку, если он отсутствует) или беззнаковое десятичное число    

Генератор случайных чисел может вызываться явно из скрипта pgbench (функциями random...) или неявно (например, для планирования выполнения транзакций с ключом --rate). В случае установки значения явным образом оно выводится в терминале. Любое значение, допустимое в качестве затравки, можно также задать в переменной окружения PGBENCH_RANDOM_SEED. Чтобы заданная затравка применялась во всех возможных случаях использования, задайте этот параметр первым или установите переменную окружения.

Явное указание определённой затравки позволяет точно воспроизвести выполнение pgbench в части использования случайных чисел. Так как случайное состояние поддерживается внутри потока, это означает, что выполнение pgbench при одинаковых запусках повторится в точности, если один поток используется одним клиентом и отсутствуют внешние зависимости или зависимости от данных. Со статистической точки зрения точное воспроизведение выполнения нежелательно, так как это может скрыть вариативность производительности или показать завышенную скорость, например из-за попадания в одни и те же страницы данных. Однако это может быть очень полезно для отладки, например, для повторения редкого сценария, приводящего к ошибке. Используйте данную возможность обдуманно.
#### --sampling-rate=скорость передачи 
Частота выборки для записи данных в протокол, изменяя которую можно уменьшить объём протокола. При указании этого параметра в протокол выводится информация только о заданном проценте транзакций. Со значением 1.0 в нём будут отмечаться все транзакции, а с 0.05 только 5%.

Обрабатывая протокол, не забудьте учесть частоту выборки. Например, вычисляя скорость (TPS), вам нужно будет соответственно умножить содержащиеся в нём числа (например, с частотой выборки 0.01 вы получите только 1/100 фактической скорости).
#### --show-script=имя_скрипта 
Вывести код встроенного скрипта имя_скрипта в stderr и сразу завершиться.
#### --verbose-errors 
Выводить сообщения обо всех ошибках сериализации/взаимоблокировки и отказах (ошибках, после которых транзакция не повторяется) с информацией о том, как ограничиваются повторения и насколько достигается ограничение. (Учтите, что в этом случае объём вывода может значительно увеличиться.) За подробностями обратитесь к Повторы и отказы из-за ошибок сериализации/взаимоблокировки.
  
</details>

<details><summary><h5>Общие параметры</h5></summary>
</details>

#### Пользовательские скрипты
Программа pgbench поддерживает запуск пользовательских сценариев оценки производительности, позволяя заменять стандартный скрипт транзакции скриптом, считываемым из файла (***с параметром -f***). В этом случае «транзакцией» считается одно выполнение данного скрипта.

Файл скрипта содержит одну или несколько команд SQL, разделённых точкой с запятой. Пустые строки и строки, начинающиеся с --, игнорируются.

#### Полезные советы
Никогда не доверяйте тестам, которые выполняются всего несколько секунд. Воспользуйтесь ***параметром -t и -T*** и установите время выполнения не меньше нескольких минут, чтобы избавиться от шума в средних значениях. В некоторых случаях для получения воспроизводимых результатов тестирование должно продолжаться несколько часов. Чтобы понять, были ли получены воспроизводимые значения, имеет смысл запустить тестирование несколько раз.

Для стандартного сценария по типу TPC-B начальный ***коэффициент масштаба (-s) должен быть не меньше числа клиентов***, с каким вы намерены проводить тестирование (-c); в противном случае вы, по большому счёту, будете замерять время конкурентных изменений. Таблица pgbench_branches содержит всего -s строк, а каждая транзакция хочет изменить одну из них, так что если значение -c превышает -s, это несомненно приведёт к тому, что многие транзакции будут блокироваться другими.

Стандартный сценарий тестирования также довольно сильно зависит от того, сколько времени прошло с момента инициализации таблиц: ***накопление неактуальных строк и «мёртвого» пространства в таблицах влияет на результаты***. Чтобы правильно оценить результаты, необходимо учитывать, сколько всего изменений было произведено и когда выполнялась очистка. ***Если же включена автоочистка, это может быть чревато непредсказуемыми изменениями*** оценок производительности.

Иногда, оценивая производительность одного сервера, полезно запускать несколько экземпляров pgbench параллельно, на отдельных клиентских компьютерах.

#### Примеры

```bash
pgbench -P 1 -c 10 -T 10 postgres
```
























